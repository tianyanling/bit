//查找两个数的最小公共祖先
//题目：有一棵无穷大的满二叉树，其结点按根结点一层一层地从左往右依次编号，根结点编号为1。
//现在有两个结点a，b。请设计一个算法，求出a和b点的最近公共祖先的编号。
//给定两个int a, b。为给定结点的编号。请返回a和b的最近公共祖先的编号。
//注意这里结点本身也可认为是其祖先。

//思路：每个结点的父亲结点为(n-1)/2（由于本题根结点是从1开始，那么父亲结点为n/2）
//当这两个数不相等时，不断查找这两个数的父亲结点，直到他们的父亲结点相等，即为这两个数的最小公共祖先。
#include<iostream>
using namespace std;

int getLCA(int a, int b)
{
	if (a == b)
	{
		return a;
	}

	while (a != b)
	{
		if (a > b)
		{
			a /= 2;//由于根结点是从编号1开始，故父亲结点的下标为n/2，
			//不断重复找这两个数的父亲结点，直到这两个数相等即为公共祖先结点
		}
		else
		{
			b /= 2;
		}
	}
	return a;
}

int main1()
{
	int a, b;
	cin >> a >> b;

	cout << getLCA(a, b) << endl;
	system("pause");
	return 0;
}